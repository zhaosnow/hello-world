#又是一个有规律的,题目. 拿到这个题目需要先思考规律. 从m到n, 如果看二进制位的话, 如果n的位数多于m的位数, 那么多出来的位数and之后一定是0, 而且最后的结果一定是0, 因为比m高一位的bit为1的时候m位所有的状态都遍历了一遍.; 如果位数相同, 那么结果一定是高位相同的部分, 否则低位部分不同, and的结果是0. 所以只需要找到高位相同的部分就行了.

# 醉了，这道题其实非常简单，从m到n， 如果m和n的最高位不同的话，一定是0， 因为每一个位上如果存在一个0，那么and的结果一定是0，所以从m到n的数字必须保证某些位上一直为1，才能保证最后的结果不为0， 一旦m和n的最高位不同，从m到n的数字中，n多出来那些位置，一定经过了为0的过程，所以结果为0。算法的巧妙之处是通过判断m是否等于n，得出前I位是否已经相等，如果相等，那么找到了前I个位一直不变的范围，如果一直不相等，那么，只能返回0

class Solution(object):
    def rangeBitwiseAnd(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        count = 0
        while n != m:
            n >>= 1
            m >>= 1
            count += 1
        return m << count
