1.给一个超级大的query_id和频率的二维数组，内存可以放下，让按照query频率的比率来随机抽取出1000个query。
一开始自己还在纠结于如何才能按照query的比率来求解，比如找到最大频率max和最小频率min然后把所有频率都归一化到
0到1之间，然而就不知怎么办了。。。。。。。
经面试官提点之后发现可以暴力求解。这里假设query为q1,q2,..,qn。query的频率为t1,t2,t3,..,tn。这样的话，对于query来说
可以开一个足够大的数组，然后前t1部分代表q1，一直往后，然后使用random函数抽取query，然而这样需要的空间比较高，没办法求解
所以我们只需要一个结构体数组存储query的起始位置以及ti，这样的话二分查找可以降到nlogn。
2.给几百t的数据，然后正类比较少，负类特别多，这样就无法直接分类，现在随机抽取一些数据进行分类，正类数目不变，负类抽取的数目是
正类的两倍，明显训练的结果不太好，那么如何使这样训练的结果和几百t数据训练的结果差不多呢，对于这样的问题，可以给负类的惩罚函数扩大
相应的倍数，结果变可以差不多，没办法没有正确回答。。。。。。。
3.一堆木头和一堆石头，石头之间，木头之间不能比较，而且石头和木头他们各自的重量都不同，但是每一个石头都有一个木头和它对应的重量相等，
那么如何找出这些一一对应的关系呢。我当时想的是利用第一个木头之间把石头分成两部分，一部分重量大于这根木头，一部分小于这根木头。然后递归
进行，这样时间复杂可以优化到nlogn。实际上使用map映射也可以进行，这样时间复杂度为O（n）http://blog.csdn.net/wcyoot/article/details/6435904
。
